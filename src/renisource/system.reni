################################################################
# System declarations
################################################################


void: /\
(
    !!converter:: /\ ();
);


bool: /\
{
    value:  ^  bit_cast(1);
    !!converter:: /\ value;
    =  : /\ bool(value = bool(^ ) value);
    <> : /\ bool(value <> bool(^ ) value);
    &  : /\ bool(value & bool(^ ) value);
    |  : /\ bool(value | bool(^ ) value);
	dump: /\ (value then string("true") else string("false"));
};


~ : /\ (false = ^ );


false:  bool(0);
true:   ~false;


repeat: /\ (^ () then repeat(^ ) else ());


integer: /\
{
	constructor integer;
    value:  ^  bit_cast(32);
    !converter: /\ value;
    + : /\ integer([value + integer(^ )value] bit_cast(32));
    - : /\ integer((value - integer(^ )value) bit_cast(32));
    * : /\ integer((value * integer(^ )value) bit_cast(32));
    / : /\ integer((value / integer(^ )value) bit_cast(32));
    \ : /\ integer((value \ integer(^ )value) bit_cast(32));
    = : /\ bool(value = integer(^ ) value);
    < : /\ bool(value < integer(^ ) value);
    > : /\ bool(value > integer(^ ) value);
    print: /\ value printnum ();

	:+ : /\{this := this + ^ ;this;};
	:* : /\{this := this * ^ ;this;};

    dump: /\
    [
        this = 0
        then string("0")
        else scope
        (
            x:  (this > 0 then this else integer(0)-this);
            Return:  string("");

            repeat(/\ scope
            (
                Digit:  integer(x \ 10);

                DigitChar:  ("0123456789" at Digit)bit_cast(8);
                DigitStr:  string((0 bit_cast(8) type)array(DigitChar,0));
                xx:  Return;
                Return := DigitStr * xx;
                x:= x / 10;
                return x > 0
            ));

            this < 0 then Return:= string("-") * Return;
            return Return
        )
    ]
};

                                                                               
- : /\ integer(0) - ^ ;


_CR_:  10 bit_cast(8);
_LF_:  13 bit_cast(8);


CBasicHeap: /\
(
	CBlock: /\ scope
	(
		ThisRef:  this explicit_ref;
		return object
		(
			constructor /\ CBlock(^ );
			Heap:  ThisRef;
			Size:  ^ ;
		);
	);

	GetBlockAndAdvance: /\ scope
	(
		Block:  (^  AT 0) raw_convert (CBlock(^  NEXT 1) explicit_ref type);
		Block()construct(^  NEXT 1);
		Return:  (Block+1) raw_convert (1 bits() explicit_ref type);
		(^  AT 0) := (Return+(^  NEXT 1)) raw_convert ((^  AT 0) type);
		return Return;

	);

	FreeArrayHandler:  prototype( /\() );

	FreeArray: /\ scope
	(
		Block:  ((^  explicit_ref) raw_convert (CBlock() explicit_ref type)) - 1;
		Block()Heap()FreeArrayHandler
		(
			Block()Size, 
			(^  explicit_ref) raw_convert(1 bits()explicit_ref type)
		);
		return;
	)
);


HeapData:  (100000 bits 0);


Heap:  object
{
	inherit CBasicHeap();

	Data:  (HeapData explicit_ref) raw_convert (1 bits()explicit_ref type);

	Allocate: /\ {scope
	{
		New:  GetBlockAndAdvance(Data, ^  type size) raw_convert(^  explicit_ref type );
		New()construct(^ );
		return New()stable_ref;
	}} stable_ref;

	AllocateArray: /\ scope
	{
		count:  ^  AT 0;
		rtype:  ^  AT 1;
		init/\:  ^  NEXT 2;
		New:  GetBlockAndAdvance(Data, count * rtype size) raw_convert(rtype() explicit_ref type);

		repeat(/\(
			count > 0 then(
				count:=count-1;
				(New at count) construct (init/\(count));
				true												 
			) else false
		));

		return New
	}; 

	FreeArrayHandler:= /\
	(
		vardump(^ )println();
	)	
};


new : /\ Heap Allocate(^ ) stable_ref;
new_array: /\ Heap AllocateArray(^ );

free_array: /\ CBasicHeap()FreeArray(^ );
	

string: /\
(
	constructor string;
    value:  (8 bits() explicit_ref type) ();

    value :=                                                             
    (
        ^  type = this type THEN scope 
        {
            ^^ Data :  ^  value;
            return new_array
            (
                ^  length()+1,
                8 bits () type,
                /\ ^ Data at ^ 
            )
        } 
		ELSE ^  type = value type THEN scope
        {
            ^ Data :  ^ ;

            ^ Length:  integer(0);
            repeat
            (/\(
                ^ Data at ^ Length <> 0
                then (^ Length := ^ Length+1; true)
                else false
            ));

            return new_array
            (
                ^ Length+1,
                8 bits () type,
                /\ ^ Data at ^ 
            )
        } 
		ELSE ^  type = () type THEN new(8 bits 0)
        ELSE new(^ )
    );

    at: /\ (value at ^ );
    
    * : /\ scope
    {
        that  :  string(^ );
        thisL :  length(); 
        thatL :  that length();
        newL  :  thisL + thatL;
		newD  :  new_array
            (newL+1, 8 bits () type, /\ (
                ^  < thisL then this at ^  else
                ^  < newL  then that at (^ -thisL) else
                0
            ))
        ; 
		Return :  string(newD);
		free_array(newD);
		return Return;
    };

	:* : /\ {this := this * ^ ;	this;};

    length: /\ scope
    (
        i:  integer(0);
        repeat
        (/\(
            value at i <> 0
            then (i := i+1; true)
            else false
        ));
        return i
    );

	dump: /\ this;

    print: /\ scope
    (
        i:  integer(0);
        repeat
        (/\(
            value at i <> 0
            then
            (
                (value at i) printchar();
                i := i+1;
                true
            )
            else
            (
                false
            )
        ));
		return
    );

    println: /\ (print();_CR_ printchar();_LF_ printchar())
);


dump: /\ 
{
    (^  type) is_explicit_ref() 
        THEN integer(^  raw_convert(^  type size bits()type))dump() ELSE
    ^  dump()
};

vardump: /\( (string(^  TEXT) * ":=" * dump(^ ) * ";") );


println: /\(_CR_ printchar();_LF_ printchar());


Array: /\ scope
{
	ElemType:  ^ ;
	return (/\
	{
		mData:  (ElemType() explicit_ref type)();
		mCount:  integer(0);
		
		(^  type) = (this type) THEN 
		{
			mCount:= ^  mCount;
			mData :=  ^  mData;
		} 
		ELSE ^  type = ElemType THEN 
		{
			mCount:= 1;
			mData :=  ^  explicit_ref;
		}
		ELSE ^  type = () type THEN ()
		ELSE scope
		{
			^ sData :  (ElemType)array(^ );
			mData := ^ sData;
			mCount:= (^ sData type size) / (ElemType size);
			return;
		};

		mCount > 0 then mData:= 
		new_array
		(
			mCount,
			ElemType,
			/\ mData at ^ 
		);

		at: /\ mData at ^ ;
		count: /\ mCount;

		* : /\ scope
		{
			that  :  Array(ElemType)(^ );
			thisL :  count(); 
			thatL :  that count();
			Return :  Array(ElemType)();
			Return mCount := mCount + thatL;
			Return mData  := 
			new_array(
				mCount, 
				ElemType, 
				/\ (^  < thisL then this at ^  else that at (^ -thisL))
			); 
			return Return;
		};

		:* : /\{this := this * ^ ; this stable_ref} stable_ref;

		dump: /\ scope
		(
			Return: string("mCount=");
			Return :* mCount dump() * "; ";
			i: integer(0);
			repeat(/\
			(
				i < mCount then scope
				(
					Return :* i dump();
					Return :* ": ";
					Return :* (mData at i) dump();
					Return :* "; ";
					i :+ 1;
					return true;
				) 
				else false;
			));		
			
			return Return;
		)	
	});
};


system:  object 
{
	compiler: /\
	{
		CBuildRule: /\
		{
			CodeFile:  string(^  AT 0);
			SourceFile:  string(^  AT 1);
			DefsFileList:  Array(string()type)(^  NEXT 2);

			dump: /\
			{
				string("CBuildRule(")
				*vardump(CodeFile)
				*vardump(SourceFile)
				*vardump(DefsFileList)
				*")"
			};
		};

		BuildRule:  Array(CBuildRule()type)();

		buildrule: /\ {BuildRule :* (CBuildRule(^ ));};

		exec: /\
		{
			string("exec;") println();
			BuildRule dump() println();
		};

	};
};


################################################################
# End
################################################################


