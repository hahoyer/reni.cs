using System.Collections.Generic;using Bnf.Base;using Bnf.Forms;using Bnf.Parser;using hw.DebugFormatter;using hw.Helper;using hw.Parser;using hw.Scanner;namespace Bnf.StructuredText{    sealed class Compiler : DumpableObject, IResultFactory<ISyntax>    {        static readonly IDictionary<string, IExpression> ParserDefinitions            = Bnf.Compiler.FromText(BnfDefinitions.Parser)                .Statements;        static readonly IDictionary<string, IExpression> ScannerDefinitions            = Bnf.Compiler.FromText(BnfDefinitions.Scanner)                .Statements;        public static Compiler FromText(string programText) => new Compiler(new Source(programText));        static ILexerTokenFactory TokenFactory => new ScannerTokenFactory(ScannerDefinitions);        public Context RootContext = Context.Root;        readonly Source Source;        IParser<ISyntax> ParserCache;        ISyntax SyntaxCache;        static Compiler() {}        Compiler(Source source) => Source = source;        ISyntax IResultFactory<ISyntax>.EmptyRepeat => new EmptySyntax();        ISyntax IResultFactory<ISyntax>.EmptySequence => new EmptySyntax();        IParser<ISyntax> Parser => ParserCache ?? (ParserCache = GetParser());        [DisableDump]        public ISyntax Syntax => SyntaxCache ?? (SyntaxCache = Parse(Source + 0));        IParser<ISyntax> GetParser()        {            ILexerTokenFactory tokenFactory = new CachingTokenFactory(TokenFactory);            var definitions = new Definitions<ISyntax>(ParserDefinitions, "structured_text");            definitions.Register(this);            return new BnfParser<ISyntax>            (                new TwoLayerScanner(tokenFactory),                definitions,                this);        }        ISyntax Parse(SourcePosn sourcePosn) => Parser.Execute(sourcePosn);    }    sealed class EmptySyntax : DumpableObject, ISyntax    {        SourcePart ISourcePartProxy.All => null;        int IParseSpan.Value => 0;    }    sealed class ScannerSyntaxError : DumpableObject, ITokenType    {        readonly IssueId IssueId;        public ScannerSyntaxError(IssueId issueId) => IssueId = issueId;        string IUniqueIdProvider.Value => "<error>";    }    interface ISyntax : ISourcePartProxy, IParseSpan {}    class Singleton : DumpableObject, ISyntax    {        readonly TokenGroup Token;        public Singleton(TokenGroup token) => Token = token;        SourcePart ISourcePartProxy.All => Token.SourcePart;        int IParseSpan.Value => 1;    }    abstract class InvalidDeclaration : DumpableObject, IDeclaration<ISyntax>    {        ISyntax IDeclaration<ISyntax>.Parse(IParserCursor source, IContext<ISyntax> context) => null;        string IDeclaration<ISyntax>.Name => Name;        protected abstract string Name {get;}    }    [BelongsTo(typeof(Compiler))]    sealed class NonRetentiveVarDeclaration : InvalidDeclaration    {        protected override string Name => "non_retentive_var_declarations";    }    [BelongsTo(typeof(Compiler))]    sealed class Nil : InvalidDeclaration    {        protected override string Name => "NIL";    }}