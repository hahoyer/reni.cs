using System.Collections.Generic;using Bnf.Base;using Bnf.Forms;using Bnf.Parser;using hw.DebugFormatter;using hw.Parser;using hw.Scanner;namespace Bnf.StructuredText{    sealed class Compiler : DumpableObject, IResultFactory<ISyntax>    {        static readonly IDictionary<string, IExpression> ParserDefinitions            = Bnf.Compiler.FromText(BnfDefinitions.Parser)                .Statements;        static readonly IDictionary<string, IExpression> ScannerDefinitions            = Bnf.Compiler.FromText(BnfDefinitions.Scanner)                .Statements;        public static Compiler FromText(string programText) => new Compiler(new Source(programText));        public Context RootContext = Context.Root;        readonly Source Source;        IParser<ISyntax> ParserCache;        ISyntax SyntaxCache;        static Compiler() {}        Compiler(Source source) => Source = source;        ISyntax IResultFactory<ISyntax>.EmptyRepeat => new EmptySyntax();        ISyntax IResultFactory<ISyntax>.EmptySequence => new EmptySyntax();        IParser<ISyntax> Parser => ParserCache ?? (ParserCache = GetParser());        [DisableDump]        public ISyntax Syntax => SyntaxCache ?? (SyntaxCache = Parse(Source + 0));        IParser<ISyntax> GetParser()        {            var definitions = new Definitions<ISyntax>(ParserDefinitions, "structured_text");            definitions.Register(this);            var scanner = CreateScanner(definitions.ParserLiteralMatch);            return new BnfParser<ISyntax>            (                scanner,                definitions,                this            );        }        static TwoLayerScanner CreateScanner(IMatch parserLiteralMatch)        {            var factory = new ScannerTokenFactory(ScannerDefinitions, parserLiteralMatch);            var cachingFactory = new CachingTokenFactory(factory);            return new TwoLayerScanner(cachingFactory);        }        ISyntax Parse(SourcePosn sourcePosn) => Parser.Execute(sourcePosn);    }    sealed class EmptySyntax : DumpableObject, ISyntax    {        SourcePart ISourcePartProxy.All => null;        int IParseSpan.Value => 0;    }    interface ISyntax : ISourcePartProxy, IParseSpan {}    sealed class Singleton : DumpableObject, ISyntax    {        readonly TokenGroup Token;        public Singleton(TokenGroup token) => Token = token;        SourcePart ISourcePartProxy.All => Token.SourcePart;        int IParseSpan.Value => 1;    }    abstract class InvalidDeclaration : DumpableObject, IDeclaration<ISyntax>    {        ISyntax IDeclaration<ISyntax>.Parse(IParserCursor source, IContext<ISyntax> context) => null;        IEnumerable<ITerminal> IDeclaration<ISyntax>.Terminals        {            get {yield break;}        }        string IDeclaration<ISyntax>.Name => Name;        protected abstract string Name {get;}    }    [BelongsTo(typeof(Compiler))]    sealed class NonRetentiveVarDeclaration : InvalidDeclaration    {        protected override string Name => "non_retentive_var_declarations";    }    [BelongsTo(typeof(Compiler))]    sealed class Nil : InvalidDeclaration    {        protected override string Name => "NIL";    }}