using System;using hw.DebugFormatter;using hw.Helper;using hw.Parser;using hw.Scanner;namespace Bnf.StructuredText{    sealed class Compiler : NewCompiler<ISyntax>    {        public static Compiler FromText(string programText) => new Compiler(new Source(programText));        public Context RootContext = Context.Root;        readonly Source Source;        ISyntax SyntaxCache;        Compiler(Source source) => Source = source;        [DisableDump]        public ISyntax Syntax => SyntaxCache ?? (SyntaxCache = Parse(Source + 0));        protected override ITokenFactory<ISyntax> TokenFactory => new ScannerTokenFactory();        ISyntax Parse(SourcePosn sourcePosn) => Parser.Execute(sourcePosn);    }    sealed class ScannerSyntaxError : DumpableObject, IScannerTokenType    {        readonly IssueId IssueId;        public ScannerSyntaxError(IssueId issueId) => IssueId = issueId;        IParserTokenFactory IScannerTokenType.ParserTokenFactory => throw new NotImplementedException();        string IScannerTokenType.Id => throw new NotImplementedException();    }    sealed class EndOfText : DumpableObject, IScannerTokenType    {        IParserTokenFactory IScannerTokenType.ParserTokenFactory => throw new NotImplementedException();        string IScannerTokenType.Id => throw new NotImplementedException();    }    sealed class BeginOfText : DumpableObject, IParserTokenType<ISyntax>    {        ISyntax IParserTokenType<ISyntax>.Create            (ISyntax left, IToken token, ISyntax right) => throw new NotImplementedException();        string IParserTokenType<ISyntax>.Id => throw new NotImplementedException();    }    abstract class NewCompiler<TSourcePart> : DumpableObject        where TSourcePart : class, ISourcePartProxy    {        IParser<TSourcePart> ParserCache;        protected IParser<TSourcePart> Parser => ParserCache ?? (ParserCache = GetParser());        protected abstract ITokenFactory<TSourcePart> TokenFactory {get;}        IParser<TSourcePart> GetParser()        {            ITokenFactory<TSourcePart> tokenFactory = new CachingTokenFactory<TSourcePart>(TokenFactory);            var beginOfText = tokenFactory.BeginOfText;            if(beginOfText == null)                return null;            return new BnfParser<TSourcePart>            (                new TwoLayerScanner(tokenFactory),                beginOfText            );        }    }    public sealed class BnfParser<TSourcePart> : DumpableObject, IParser<TSourcePart>        where TSourcePart : class, ISourcePartProxy    {        readonly IScanner Scanner;        readonly IParserTokenType<TSourcePart> StartParserType;        public BnfParser(IScanner scanner, IParserTokenType<TSourcePart> startParserType)        {            Scanner = scanner;            StartParserType = startParserType;        }        public bool Trace {get; set;}        TSourcePart IParser<TSourcePart>.Execute(SourcePosn start)        {            var g = Scanner.GetNextTokenGroup(start);            NotImplementedMethod(start);            return null;        }    }    interface ISyntax : ISourcePartProxy {}    class Context : DumpableObject    {        public static readonly Context Root = new RootContext();        public Context WithVariable(string name, DataType dataType) => new ContextWithVariable(this, name, dataType);    }    sealed class ContextWithVariable : Context    {        readonly DataType DataType;        readonly string Name;        readonly Context Parent;        public ContextWithVariable(Context parent, string name, DataType dataType)        {            Parent = parent;            Name = name;            DataType = dataType;        }    }    sealed class RootContext : Context {}    class DataType    {        public static readonly DataType Integer = new DataType();        readonly FunctionCache<int, DataType> ArrayCache;        public DataType() {ArrayCache = new FunctionCache<int, DataType>(i => new ArrayType(i));}        public DataType Array(int count) => ArrayCache[count];    }    sealed class ArrayType : DataType    {        readonly int Count;        public ArrayType(int count) => Count = count;    }}