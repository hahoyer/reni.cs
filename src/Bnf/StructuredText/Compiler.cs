using System;using hw.DebugFormatter;using hw.Helper;using hw.Parser;using hw.Scanner;namespace Bnf.StructuredText{    abstract class NewCompiler<TSourcePart> : DumpableObject        where TSourcePart : class, ISourcePartProxy    {        IParser<TSourcePart> ParserCache;        protected IParser<TSourcePart> Parser => ParserCache ?? (ParserCache = GetParser());        protected abstract ILexerTokenFactory TokenFactory {get;}        IParser<TSourcePart> GetParser()        {            ILexerTokenFactory tokenFactory = new CachingTokenFactory(TokenFactory);            return new BnfParser<TSourcePart>            (                new TwoLayerScanner(tokenFactory)            );        }    }    sealed class Compiler : NewCompiler<ISyntax>    {        public static Compiler FromText(string programText) => new Compiler(new Source(programText));        public Context RootContext = Context.Root;        readonly Source Source;        TokenFactory Factory;        ISyntax SyntaxCache;        Compiler(Source source)        {            Source = source;            Factory = new TokenFactory();        }        [DisableDump]        public ISyntax Syntax => SyntaxCache ?? (SyntaxCache = Parse(Source + 0));        protected override ILexerTokenFactory TokenFactory => new ScannerTokenFactory();        ISyntax Parse(SourcePosn sourcePosn) => Parser.Execute(sourcePosn);    }    sealed class TokenFactory : GenericTokenFactory    {        public TokenFactory(string title = null)            : base(title) {}        protected override ITokenType NewSymbol(string name) => new UserSymbol(name);    }    sealed class ScannerSyntaxError : DumpableObject, ITokenType    {        readonly IssueId IssueId;        public ScannerSyntaxError(IssueId issueId) => IssueId = issueId;        string IUniqueIdProvider.Value => throw new NotImplementedException();    }    sealed class EndOfText : DumpableObject, ITokenType     {        string IUniqueIdProvider.Value => throw new NotImplementedException();    }    interface ISyntax : ISourcePartProxy    {    }    abstract class TokenClass : DumpableObject, ITokenType    {        string IUniqueIdProvider.Value => Id;        [DisableDump]        protected abstract string Id {get;}        protected override string GetNodeDump() => GetType().PrettyName() + "(" + Id.Quote() + ")";    }    sealed class UserSymbol : TokenClass    {        public UserSymbol(string name) => Id = name;        [DisableDump]        protected override string Id {get;}    }}